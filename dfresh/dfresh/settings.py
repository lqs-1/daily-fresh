"""
Django settings for dfresh project.

Generated by 'django-admin startproject' using Django 3.2.10.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.2/ref/settings/
"""
import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
APPEND_SLASH = False

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-@tkde^*z+znbts68^t_m56nt1cl)a)7%k2fhstwtojl!)0ypgq'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'haystack',
    'corsheaders',
    'apps.user',
    'apps.order',
    'apps.cart',
    'apps.goods'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]



#跨域增加忽略
CORS_ALLOW_CREDENTIALS = True
CORS_ORIGIN_ALLOW_ALL = True
CORS_ORIGIN_WHITELIST = ('http://127.0.0.1:8000',)
#
# # 跨站
CORS_ALLOW_METHODS = (
#     'DELETE',
#     'GET',
#     'OPTIONS',
#     'PATCH',
    'POST',
#     'PUT',
#     'VIEW',
)
#
# CORS_ALLOW_HEADERS = (
#     'XMLHttpRequest',
#     'X_FILENAME',
#     'accept-encoding',
#     'authorization',
#     'content-type',
#     'dnt',
#     'origin',
#     'user-agent',
#     'x-csrftoken',
#     'x-requested-with',
#     'Pragma',
# )


ROOT_URLCONF = 'dfresh.urls'



TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'dfresh.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'fresh',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'lqs',
        'PORT': 3306,
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

LANGUAGE_CODE = 'zh-hans'

TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
)


MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'static/media')

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

AUTH_USER_MODEL = 'user.User'


log_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'logs')
if not os.path.exists(log_dir):
    os.mkdir(log_dir)

import time

LOGGING = {
    # 版本
    'version': 1,
    # 是否禁用默认的日志管理
    'disable_existing_loggers': True,

    # 输出格式
    'formatters': {
        # 日志标准格式
        'standard': {
            'format': '[%(asctime)s] [%(filename)s:%(lineno)d] [%(module)s:%(funcName)s] '
                      '[%(levelname)s]- %(message)s'},
        # 日志简单格式
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
    },

    # 过滤，一般不设置
    'filters': {
    },

    # 定义具体处理日志的方式
    'handlers': {
        # 默认记录所有日志
        'default': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(log_dir, 'all-{}.log'.format(time.strftime('%Y-%m-%d'))),
            'maxBytes': 1024 * 1024 * 5,  # 文件大小
            'backupCount': 5,  # 备份数
            'formatter': 'standard',  # 输出格式
            'encoding': 'utf-8',  # 设置默认编码，否则打印出来汉字乱码
        },
        # 输出错误日志
        'error': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(log_dir, 'error-{}.log'.format(time.strftime('%Y-%m-%d'))),
            'maxBytes': 1024 * 1024 * 5,  # 文件大小
            'backupCount': 5,  # 备份数
            'formatter': 'standard',  # 输出格式
            'encoding': 'utf-8',  # 设置默认编码
        },
        # 控制台输出
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'standard'
        },
        # 输出info日志
        'info': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(log_dir, 'info-{}.log'.format(time.strftime('%Y-%m-%d'))),
            'maxBytes': 1024 * 1024 * 5,
            'backupCount': 5,
            'formatter': 'standard',
            'encoding': 'utf-8',  # 设置默认编码
        },
    },
    # 配置用哪几种 handlers 来处理日志
    'loggers': {
        # 类型 为 lqs 处理所有类型的日志， 默认调用
        'default': {
            'handlers': ['default', 'console'],
            'level': 'INFO',
        },
        # log 调用时需要当作参数传入
        'log': {
            'handlers': ['error', 'info', 'console', 'default'],
            'level': 'INFO',
        },
    }
}



# 发送邮件设置
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend' #固定写法
EMAIL_HOST = 'smtp.qq.com' #SMTP地址
EMAIL_PORT = 25 #SMTP端口
EMAIL_HOST_USER = '749062870@qq.com' #发送邮件的邮箱
EMAIL_HOST_PASSWORD = 'xwavsdrfyoigbfeb'  # 授权码
# EMAIL_SUBJECT_PREFIX = '小松' #为邮件Subject-line前缀,默认是'[django]'
# EMAIL_USE_TLS = True  # 与SMTP服务器通信时，是否启动TLS链接(安全链接)默认false
# EMAIL_USE_SSL = True        # SSL加密方式
#收件人看到的发件人，必须和上面的邮箱一样，否则发不出去
EMAIL_FROM = '天天生鲜<749062870@qq.com>'






#下面就是logging的配置
LOGGING = {
    'version': 1,  # 指明dictConnfig的版本，目前就只有一个版本，哈哈
    'disable_existing_loggers': False,  # 表示是否禁用所有的已经存在的日志配置
    'formatters': {  # 格式器
        'verbose': {  # 详细
            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
        },
        'standard': {  # 标准
            'format': '[%(asctime)s] [%(levelname)s] %(message)s'
        },
    },
    # handlers：用来定义具体处理日志的方式，可以定义多种，"default"就是默认方式，"console"就是打印到控制台方式。file是写入到文件的方式，注意使用的class不同
    'handlers': { # 处理器，在这里定义了两个个处理器
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            # 'stream': 'ext://sys.stdout',   # 文件重定向的配置，将打印到控制台的信息都重定向出去 python manage.py runserver >> /home/aea/log/test.log
            'stream': open(os.path.join(BASE_DIR, f'{log_dir}/all-log.log'), 'a'),  #虽然成功了，但是并没有将所有内容全部写入文件，目前还不清楚为什么
            'formatter': 'standard'   # 制定输出的格式，注意 在上面的formatters配置里面选择一个，否则会报错
        },
        'file': {
            'level': 'ERROR',
            'class': 'logging.FileHandler',
            'filename': os.path.join(log_dir, 'error{}.log'.format(time.strftime('%Y-%m-%d'))),  #这是将普通日志写入到日志文件中的方法，
            'formatter': 'standard'
        },
        # 'default': {
        #     'level':'DEBUG',
        #     'class':'logging.handlers.RotatingFileHandler',
        #     'filename': os.path.join(log_dir, 'default.log'.format(time.strftime('%Y-%m-%d'))),   #日志输出文件
        #     'maxBytes': 1024*1024*5,                  #文件大小
        #     'backupCount': 5,                         #备份份数
        #     'formatter':'standard',                   #使用哪种formatters日志格式
        # },
        # 上面两种写入日志的方法是有区别的，前者是将控制台下输出的内容全部写入到文件中，这样做的好处就是我们在views代码中的所有print也会写在对应的位置
        # 第二种方法就是将系统内定的内容写入到文件，具体就是请求的地址、错误信息等，小伙伴也可以都使用一下然后查看两个文件的异同。
    },
    'loggers': {  # log记录器，配置之后就会对应的输出日志
        # django 表示就是django本身默认的控制台输出，就是原本在控制台里面输出的内容，在这里的handlers里的file表示写入到上面配置的file-/home/aea/log/jwt_test.log文件里面
        # 在这里的handlers里的console表示写入到上面配置的console-/home/aea/log/test.log文件里面
        'django': {
            'handlers': ['console','file'],
            # 这里直接输出到控制台只是请求的路由等系统console，当使用重定向之后会把所有内容输出到log日志
            'level': 'DEBUG',
            'propagate': True,
        },

    },
}


CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# Django 默认可以使用任何 cache backend 作为 session backend, 将 django-redis 作为 session 储存后端不用安装任何额外的 backend
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"

# 自定义的fdfs文件服务器
# DEFAULT_FILE_STORAGE = 'utils.storage.FastDFSStorage'


# 使用oss
# pip install oss2
# pip install django-oss2-storage
# 使用OSS存储文件
DEFAULT_FILE_STORAGE = 'aliyun_oss2_storage.backends.AliyunMediaStorage'

# 配置OSS信息
ACCESS_KEY_ID = "LTAI5tMMRUVcNmfWrM5RjUyX"
ACCESS_KEY_SECRET = "Fchr5xqVXddeT869ptwf6TfthZ9tOE"
PREFIX_URL = 'https://'
END_POINT = "oss-cn-chengdu.aliyuncs.com"  # OSS存储节点，基本上只要改城市
BUCKET_NAME = "lqs-fresh"
BUCKET_ACL_TYPE = "public-read"  # private, public-read, public-read-write


# 设置上传的静态文件，需要上传静态文件的记得添加此项
# STATICFILES_STORAGE = 'aliyun_oss2_storage.backends.AliyunStaticStorage'
ALIYUB_OSS_BASE_URL = "https://lqs-fresh.oss-cn-chengdu.aliyuncs.com/media/"

ALIYUN_OSS_CNAME = ""  # 自定义域名，如果不需要可以不填写








FDFS_CLIENT = 'config/client.conf'
FDFS_BASE_URL = 'http://172.17.0.3:8888/'


LOGIN_URL = '/user/login'

# 支付宝
with open(os.path.join(BASE_DIR, "config/app_private_key.pem"), "rb") as pf:
    APP_PRIVATE_KEY_STR = pf.read()

with open(os.path.join(BASE_DIR, "config/alipay_public_key.pem"), "rb") as pf:
    ALIPAY_PUBLIC_KEY_STR = pf.read()

ALIPAY_BASE_URL = "https://openapi.alipaydev.com/gateway.do?"


# 全文检索框架配置
HAYSTACK_CONNECTIONS = {
    'default': {
        # 配置使用whoosh引擎
        'ENGINE': 'haystack.backends.whoosh_cn_backend.WhooshEngine',
        # 'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
        # 检索文件路径, 自动生成
        'PATH': os.path.join(BASE_DIR, 'whoosh.index')

        # 'URL': 'http://127.0.0.1:8983/solr'
        # ...or for multicore...
        # 'URL': 'http://127.0.0.1:8983/solr/mysite',
    },
}
# 当增删查改数据时候自动生成索引
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
'''
    分词器使用：
        安装全文检索框架：pip install django-haystack
        安装搜索引擎：pip install whoosh
        安装jieba分词器: pip install jieba
        
        whoosh路径：....../site-packages/whoosh
        haystack路径：....../site-packages/haystack
        haystack默认引擎路径：....../site-packages/haystack/backends
        
        
        第一步：
        在settings文件中配置：
            注册应用haystack
            HAYSTACK_CONNECTIONS = {
                'default': {
                    # 配置使用whoosh引擎，cn版本是我们加了jieba分词器之后的whoosh引擎，原始版本不能删除
                    'ENGINE': 'haystack.backends.whoosh_cn_backend.WhooshEngine',
                    # 'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
                    # 检索文件路径, 自动生成
                    'PATH': os.path.join(BASE_DIR, 'whoosh.index')
                },
            }
            # 当增删查改数据时候自动生成索引
            HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
            
        第二步：
        编写索引类：
            索引类定义在需要进行所搜的应用模块下面
            索引类名：模型类名+Index, 如（GoodsSKUIndex）
            
            # 定义索引类
            from haystack import indexes
            from .models import GoodsSKU
            
            # 指定对于某个类的某些数据建立索引
            # 索引类名格式： 模型类名+Index
            class GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):
                # 索引类里面的索引字段
                # use_template：指定根据表中的哪些字段建立索引文件， 把说明放在一个文件中
                text = indexes.CharField(document=True, use_template=True)
                # 返回模型类
                def get_model(self):
                    # 返回你的模型类
                    return GoodsSKU
                # 建立索引的数据
                def index_queryset(self, using=None):
                    return self.get_model().objects.all()
                    
        第三步：
        建立索引文件
            在templates文件夹下创建search/indexes/数据模型类所属的应用名/数据模型类类名小写_text.txt
            在这个txt文件中书写指定根据表中的哪些字段建立索引
            {{object.name}}  # 根据商品名称建立索引
            {{object.desc}}  # 根据商品描述建立索引
            {{object.goods.detail}}  # 根据商品详情建立索引
            
        第四步：
        python manager.py rebuild_index  生成检索文件
        
        第五步：
        配置haystack路由: 
            path('search', include('haystack.urls')),  # 配置全文检索框架路由
            
        第六步：
        在search/indexes/下创建一个search.html文件，来展示结果
            query对象：搜索的关键字
            搜索的关键字{{ query }}<br>
            
            page对象：搜索结果，便利出来通过object.xxx使用，有以下作用
            遍历对象
            {% for item in page %}
                {{ item.object.name }}
            {% endfor %}
            判断上一页下一页：
            {% if page.has_previous %}<a href="/search?q={{ query }}&page={{ page.previous_page_number }}">下一页></a>{% endif %}
            {% if page.has_next %}<a href="/search?q={{ query }}&page={{ page.next_page_number }}">下一页></a>{% endif %}
            判断是否是当前页：
            {% if pindex == page.number %}
            
            {#Page对象可以便历出来，便历的都是SearchResult实例对象，里面的object供我们使用#}
            
            分页的Paginator对象{{ paginator }}<br>
           {% for pindex in paginator.page_range %}
                {% if pindex == page.number %}
                    <a href="/search?q={{ query }}&page={{ pindex }}" class="active">{{ pindex }}</a>
                {% else%}
                    <a href="/search?q={{ query }}&page={{ pindex }}">{{ pindex }}</a>
                {% endif %}
            {% endfor %}
            
            
        第七步：
        更换分词器（jieba）：
        在/site-packages/haystack/backends下创建ChineseAnalyzer.py，内容网上搜索
        在/site-packages/haystack/backends下复制一份whoosh_backend.py并且改名为whoosh_cn_backend.py,然后修改里面analyzer=ChineseTokenizer(),先引入，再使用
        在配置文件中修改使用的whoosh引擎为whoosh_cn_backend
        
        重新生成检索文件：python manager.py rebuild_index

'''
